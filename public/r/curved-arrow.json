{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "curved-arrow",
  "type": "registry:block",
  "title": "Dynamic Curved Arrows",
  "description": "Connect any two elements with beautiful, animated paths. Control curve shape, routing, layering, arrowheads, gradients, and responsive behavior in real-time.",
  "registryDependencies": [
    "badge",
    "button"
  ],
  "files": [
    {
      "path": "components/ui/curved-arrow.tsx",
      "content": "/**\n * CurvedArrow\n *\n * A highly-flexible, DOM-aware SVG connector for drawing animated, curved arrows\n * between two elements or coordinates. Supports gradient strokes, multiple curve\n * styles, head shapes, obstacle avoidance, and two-layer rendering for correct\n * z-index stacking relative to page content.\n *\n * Coordinate system and container\n * - This component renders two absolutely positioned containers (UNDER and OVER)\n *   as siblings at the same DOM level, each with inset-0. They should be mounted\n *   inside a relatively positioned parent (e.g. className=\"relative\") so the\n *   arrows align to that box.\n * - All geometry (start/end points, obstacles) are calculated relative to the\n *   UNDER container's boundingClientRect, which (when inset-0) matches the\n *   parent container's rect.\n *\n * Layering (z-index contract)\n * - Elements (your draggable boxes, etc.) should be placed in either:\n *   - z-1: \"Under arrow\" elements\n *   - z-5: \"Over arrow\" elements\n * - The arrow renders in two sibling layers:\n *   - z-2: UNDER layer (base line + any heads configured to \"under\")\n *   - z-4: OVER layer (heads configured to \"over\" + optional overlays)\n * This guarantees:\n *   - \"Under\" elements sit below the entire arrow (base line and any under-heads).\n *   - Heads marked \"over\" appear above \"under\" elements but below \"over\" elements.\n *   - \"Over\" elements always sit on top of the arrow.\n *\n * Accessibility\n * - The UNDER layer container has role=\"img\" and an aria-label describing the connector.\n * - The OVER layer is aria-hidden since it only contributes head overlays by design.\n *\n * Performance\n * - Uses ResizeObserver and MutationObserver to track geometry changes of the start,\n *   end, and obstacle elements.\n * - Batches updates via requestAnimationFrame and avoids state churn when geometry\n *   deltas are insignificant.\n *\n * Usage (basic)\n *   const aRef = useRef<HTMLDivElement>(null)\n *   const bRef = useRef<HTMLDivElement>(null)\n *   return (\n *     <div className=\"relative\">\n *       <div ref={aRef} className=\"z-1\">A</div>\n *       <div ref={bRef} className=\"z-5\">B</div>\n *       <CurvedArrow startElement={aRef} endElement={bRef} />\n *     </div>\n *   )\n *\n * Notes\n * - If you don't use startElement/endElement refs, you can render by coordinates using\n *   startX/startY/endX/endY instead.\n * - For obstacle avoidance, pass obstacleElements as an array of refs. A simple\n *   heuristic path will be produced when curveType is \"around-obstacle\" or \"shortest-path\".\n */\n\n\"use client\"\n\nimport * as React from \"react\"\nimport { useEffect, useState, useRef, useCallback } from \"react\"\nimport { cn } from \"@/lib/utils\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\n/**\n * Variants for styling the arrow container with Tailwind classes.\n * Note: These classes apply to the wrapper that contains <svg> layers.\n */\nconst curvedArrowVariants = cva(\"absolute inset-0 pointer-events-none\", {\n  variants: {\n    variant: {\n      default: \"drop-shadow-md\",\n      glow: \"drop-shadow-[0_4px_12px_rgba(133,45,238,0.3)]\",\n      subtle: \"drop-shadow-sm opacity-80\",\n      bold: \"drop-shadow-lg\",\n      neon: \"drop-shadow-[0_0_20px_rgba(0,255,255,0.6)]\",\n      fire: \"drop-shadow-[0_0_15px_rgba(255,69,0,0.8)]\",\n      ice: \"drop-shadow-[0_0_12px_rgba(173,216,230,0.7)]\",\n      electric: \"drop-shadow-[0_0_18px_rgba(255,255,0,0.6)]\",\n      shadow: \"drop-shadow-[4px_4px_8px_rgba(0,0,0,0.3)]\",\n      rainbow: \"drop-shadow-[0_0_10px_rgba(255,0,255,0.4)]\",\n      cosmic: \"drop-shadow-[0_0_25px_rgba(138,43,226,0.5)]\",\n      emerald: \"drop-shadow-[0_0_15px_rgba(16,185,129,0.6)]\",\n      rose: \"drop-shadow-[0_0_12px_rgba(244,63,94,0.5)]\",\n      amber: \"drop-shadow-[0_0_14px_rgba(245,158,11,0.6)]\",\n      violet: \"drop-shadow-[0_0_16px_rgba(139,92,246,0.5)]\",\n      cyan: \"drop-shadow-[0_0_13px_rgba(6,182,212,0.6)]\",\n      lime: \"drop-shadow-[0_0_11px_rgba(132,204,22,0.5)]\",\n      pink: \"drop-shadow-[0_0_17px_rgba(236,72,153,0.6)]\",\n      indigo: \"drop-shadow-[0_0_15px_rgba(99,102,241,0.5)]\",\n      teal: \"drop-shadow-[0_0_12px_rgba(20,184,166,0.6)]\",\n      orange: \"drop-shadow-[0_0_14px_rgba(249,115,22,0.5)]\",\n      slate: \"drop-shadow-[0_0_10px_rgba(100,116,139,0.4)]\",\n    },\n    size: {\n      xs: \"[&_path]:stroke-[1px]\",\n      sm: \"[&_path]:stroke-[2px]\",\n      default: \"[&_path]:stroke-[4px]\",\n      lg: \"[&_path]:stroke-[6px]\",\n      xl: \"[&_path]:stroke-[8px]\",\n      \"2xl\": \"[&_path]:stroke-[10px]\",\n      \"3xl\": \"[&_path]:stroke-[12px]\",\n      \"4xl\": \"[&_path]:stroke-[14px]\",\n      \"5xl\": \"[&_path]:stroke-[16px]\",\n      \"6xl\": \"[&_path]:stroke-[18px]\",\n      \"7xl\": \"[&_path]:stroke-[20px]\",\n      \"8xl\": \"[&_path]:stroke-[22px]\",\n      \"9xl\": \"[&_path]:stroke-[24px]\",\n    },\n  },\n  defaultVariants: {\n    variant: \"default\",\n    size: \"default\",\n  },\n})\n\n/**\n * Bounding rectangle for obstacles, measured relative to the canvas/container.\n */\ntype RectLite = { x: number; y: number; width: number; height: number }\n\n/**\n * Component props for CurvedArrow.\n *\n * Most props are optional with sensible defaults. You can either:\n * - Provide element refs (startElement, endElement) with position docking via startPosition/endPosition; or\n * - Provide absolute coordinates (startX, startY, endX, endY).\n */\nexport interface CurvedArrowProps extends VariantProps<typeof curvedArrowVariants> {\n  /**\n   * Reference to the element used as the start anchor.\n   * When provided, startX/startY are ignored and computed from this element using startPosition.\n   */\n  startElement?: React.RefObject<HTMLElement>\n  /**\n   * Reference to the element used as the end anchor.\n   * When provided, endX/endY are ignored and computed from this element using endPosition.\n   */\n  endElement?: React.RefObject<HTMLElement>\n\n  /**\n   * Optional array of obstacle element refs. When present and curveType is\n   * \"around-obstacle\" or \"shortest-path\", a basic waypoint path is calculated\n   * to detour around these obstacles.\n   */\n  obstacleElements?: React.RefObject<HTMLElement>[]\n\n  /**\n   * Absolute start X coordinate (used if startElement is not provided).\n   */\n  startX?: number\n  /**\n   * Absolute start Y coordinate (used if startElement is not provided).\n   */\n  startY?: number\n  /**\n   * Absolute end X coordinate (used if endElement is not provided).\n   */\n  endX?: number\n  /**\n   * Absolute end Y coordinate (used if endElement is not provided).\n   */\n  endY?: number\n\n  /**\n   * Docking position for startElement (applies padding to sit just outside the element).\n   * Examples: \"top\", \"right-center\", \"center-bottom\", etc.\n   */\n  startPosition?:\n    | \"top\"\n    | \"bottom\"\n    | \"left\"\n    | \"right\"\n    | \"center\"\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n    | \"top-center\"\n    | \"bottom-center\"\n    | \"left-center\"\n    | \"right-center\"\n    | \"middle-left\"\n    | \"middle-right\"\n    | \"middle-top\"\n    | \"middle-bottom\"\n    | \"center-left\"\n    | \"center-right\"\n    | \"center-top\"\n    | \"center-bottom\"\n\n  /**\n   * Docking position for endElement (applies padding to sit just outside the element).\n   */\n  endPosition?:\n    | \"top\"\n    | \"bottom\"\n    | \"left\"\n    | \"right\"\n    | \"center\"\n    | \"top-left\"\n    | \"top-right\"\n    | \"bottom-left\"\n    | \"bottom-right\"\n    | \"top-center\"\n    | \"bottom-center\"\n    | \"left-center\"\n    | \"right-center\"\n    | \"middle-left\"\n    | \"middle-right\"\n    | \"middle-top\"\n    | \"middle-bottom\"\n    | \"center-left\"\n    | \"center-right\"\n    | \"center-top\"\n    | \"center-bottom\"\n\n  /**\n   * Intensity of curvature (0..1+). Higher values bow further.\n   * Default: 0.4\n   */\n  curveIntensity?: number\n  /**\n   * Curve style preset controlling control points/segments.\n   * Default: \"smooth\"\n   */\n  curveType?:\n    | \"smooth\"\n    | \"dramatic\"\n    | \"s-curve\"\n    | \"wave\"\n    | \"spiral\" // reserved for future implementation\n    | \"elegant\"\n    | \"around-obstacle\"\n    | \"shortest-path\"\n    | \"zigzag\"\n    | \"loop\" // reserved for future implementation\n    | \"heart\" // reserved for future implementation\n    | \"infinity\" // reserved for future implementation\n  /**\n   * Directional bias for control points. When \"auto\", chooses based on relative deltas.\n   * Default: \"auto\"\n   */\n  curveDirection?: \"up\" | \"down\" | \"left\" | \"right\" | \"auto\"\n\n  /**\n   * Base stroke width for the main path (not including any glow).\n   * Default: 4\n   */\n  strokeWidth?: number\n  /**\n   * Base size for arrowheads when startArrowSize/endArrowSize are not provided.\n   * Default: 20\n   */\n  arrowSize?: number\n  /**\n   * Solid color used when gradientFrom/gradientTo are not set.\n   * Default: \"#852DEE\"\n   */\n  color?: string\n  /**\n   * Start of linear gradient color; when both gradientFrom and gradientTo are defined,\n   * the arrow will be stroked by a gradient instead of solid color.\n   * Default: \"#ffffff\"\n   */\n  gradientFrom?: string\n  /**\n   * End of linear gradient color.\n   * Default: \"#852DEE\"\n   */\n  gradientTo?: string\n\n  /**\n   * Toggle visibility of the start arrowhead.\n   * Default: false\n   */\n  showStartArrow?: boolean\n  /**\n   * Toggle visibility of the end arrowhead.\n   * Default: true\n   */\n  showEndArrow?: boolean\n\n  /**\n   * Shape preset for start arrowhead.\n   * Default: \"triangle\"\n   */\n  startArrowShape?:\n    | \"triangle\"\n    | \"circle\"\n    | \"square\"\n    | \"diamond\"\n    | \"star\"\n    | \"heart\"\n    | \"cross\"\n    | \"plus\"\n    | \"chevron\"\n    | \"double-chevron\"\n    | \"arrow\"\n    | \"hollow-triangle\"\n    | \"hollow-circle\"\n    | \"hollow-square\"\n    | \"hollow-diamond\"\n    | \"filled-circle\"\n    | \"filled-square\"\n    | \"filled-diamond\"\n    | \"filled-triangle\"\n    | \"line\"\n    | \"dot\"\n    | \"dash\"\n\n  /**\n   * Shape preset for end arrowhead.\n   * Default: \"triangle\"\n   */\n  endArrowShape?:\n    | \"triangle\"\n    | \"circle\"\n    | \"square\"\n    | \"diamond\"\n    | \"star\"\n    | \"heart\"\n    | \"cross\"\n    | \"plus\"\n    | \"chevron\"\n    | \"double-chevron\"\n    | \"arrow\"\n    | \"hollow-triangle\"\n    | \"hollow-circle\"\n    | \"hollow-square\"\n    | \"hollow-diamond\"\n    | \"filled-circle\"\n    | \"filled-square\"\n    | \"filled-diamond\"\n    | \"filled-triangle\"\n    | \"line\"\n    | \"dot\"\n    | \"dash\"\n\n  /**\n   * Additional rotation to apply to the start arrowhead, in degrees.\n   * Default: 0\n   */\n  startArrowRotation?: number\n  /**\n   * Additional rotation to apply to the end arrowhead, in degrees.\n   * Default: 0\n   */\n  endArrowRotation?: number\n\n  /**\n   * Override size for the start arrowhead (falls back to arrowSize).\n   */\n  startArrowSize?: number\n  /**\n   * Override size for the end arrowhead (falls back to arrowSize).\n   */\n  endArrowSize?: number\n\n  /**\n   * When true, fill the start arrowhead with the stroke color/gradient.\n   * Default: false\n   */\n  startArrowFilled?: boolean\n  /**\n   * When true, fill the end arrowhead with the stroke color/gradient.\n   * Default: false\n   */\n  endArrowFilled?: boolean\n\n  /**\n   * Per-head stroke color overrides (falls back to gradient or color).\n   */\n  startArrowStrokeColor?: string\n  endArrowStrokeColor?: string\n  /**\n   * Per-head fill color overrides (falls back to gradient or color when filled).\n   */\n  startArrowFillColor?: string\n  endArrowFillColor?: string\n\n  /**\n   * Per-head stroke widths (falls back to strokeWidth).\n   */\n  startArrowStrokeWidth?: number\n  endArrowStrokeWidth?: number\n\n  /**\n   * Per-head opacity (0..1).\n   */\n  startArrowOpacity?: number\n  endArrowOpacity?: number\n\n  /**\n   * Layer on which to render the start arrowhead.\n   * \"under\" = in the UNDER SVG, \"over\" = in the OVER SVG.\n   * Default: \"over\"\n   */\n  startHeadLayer?: \"under\" | \"over\"\n  /**\n   * Layer on which to render the end arrowhead.\n   * Default: \"over\"\n   */\n  endHeadLayer?: \"under\" | \"over\"\n\n  /**\n   * If true and the head is on the same layer as the line, draw a short overlay segment\n   * so the line visually overlaps the head for a cleaner look.\n   * Default: false\n   */\n  startLineOverHead?: boolean\n  endLineOverHead?: boolean\n\n  /**\n   * Enable white animated dash overlay on the main path.\n   * Default: true\n   */\n  animated?: boolean\n  /**\n   * CSS time for one dash cycle (e.g., \"2s\").\n   * Default: \"2s\"\n   */\n  animationDuration?: string\n  /**\n   * CSS delay before animation starts (e.g., \"0.3s\").\n   * Default: \"0s\"\n   */\n  animationDelay?: string\n  /**\n   * Animation direction mode.\n   * Default: \"forward\"\n   */\n  animationDirection?: \"forward\" | \"reverse\" | \"alternate\" | \"alternate-reverse\"\n\n  /**\n   * Accessible label applied to the UNDER container (role=\"img\").\n   * Default: \"Curved arrow connector\"\n   */\n  ariaLabel?: string\n\n  /**\n   * Additional className merged into the container class variants.\n   */\n  className?: string\n}\n\n/**\n * Build an SVG path string for an arrowhead centered at (x, y).\n *\n * @param x - Head tip X coordinate.\n * @param y - Head tip Y coordinate.\n * @param angle - Base direction angle (radians) for the head tip orientation.\n * @param size - Base size of the head.\n * @param shape - Named shape preset.\n * @param rotation - Additional rotation in degrees applied around (x, y).\n * @param forceFilled - When true, some outlines become closed fills for better visuals.\n * @returns An SVG path \"d\" string describing the head geometry.\n */\nconst createArrowHead = (\n  x: number,\n  y: number,\n  angle: number,\n  size: number,\n  shape: string,\n  rotation = 0,\n  forceFilled = false,\n) => {\n  const totalAngle = angle + (rotation * Math.PI) / 180\n  const cos = Math.cos(totalAngle)\n  const sin = Math.sin(totalAngle)\n\n  // When forceFilled is true and shape is typically stroked, create a filled triangle shell.\n  if (forceFilled && (shape === \"triangle\" || shape === \"arrow\" || shape === \"hollow-triangle\")) {\n    const a = Math.PI / 6\n    const fx1 = x - size * Math.cos(totalAngle - a)\n    const fy1 = y - size * Math.sin(totalAngle - a)\n    const fx2 = x - size * Math.cos(totalAngle + a)\n    const fy2 = y - size * Math.sin(totalAngle + a)\n    return `M ${x} ${y} L ${fx1} ${fy1} L ${fx2} ${fy2} Z`\n  }\n\n  // Shape presets. Many outline shapes rely on stroke attributes from the caller.\n  switch (shape) {\n    case \"triangle\":\n    case \"arrow\": {\n      const a = Math.PI / 6\n      const x1 = x - size * Math.cos(totalAngle - a)\n      const y1 = y - size * Math.sin(totalAngle - a)\n      const x2 = x - size * Math.cos(totalAngle + a)\n      const y2 = y - size * Math.sin(totalAngle + a)\n      return `M ${x} ${y} L ${x1} ${y1} M ${x} ${y} L ${x2} ${y2}`\n    }\n    case \"filled-triangle\": {\n      const a = Math.PI / 6\n      const fx1 = x - size * Math.cos(totalAngle - a)\n      const fy1 = y - size * Math.sin(totalAngle - a)\n      const fx2 = x - size * Math.cos(totalAngle + a)\n      const fy2 = y - size * Math.sin(totalAngle + a)\n      return `M ${x} ${y} L ${fx1} ${fy1} L ${fx2} ${fy2} Z`\n    }\n    case \"circle\":\n    case \"filled-circle\":\n      return `M ${x + size * cos} ${y + size * sin} A ${size} ${size} 0 1 1 ${x - size * cos} ${y - size * sin} A ${size} ${size} 0 1 1 ${x + size * cos} ${y + size * sin}`\n    case \"hollow-circle\": {\n      const r = size * 0.6\n      return `M ${x + size * cos} ${y + size * sin} A ${size} ${size} 0 1 1 ${x - size * cos} ${y - size * sin} A ${size} ${size} 0 1 1 ${x + size * cos} ${y + size * sin} M ${x + r * cos} ${y + r * sin} A ${r} ${r} 0 1 0 ${x - r * cos} ${y - r * sin} A ${r} ${r} 0 1 0 ${x + r * cos} ${y + r * sin}`\n    }\n    case \"square\":\n    case \"filled-square\": {\n      const h = size * 0.7\n      const pts = [\n        [x + h * cos - h * sin, y + h * sin + h * cos],\n        [x + h * cos + h * sin, y + h * sin - h * cos],\n        [x - h * cos + h * sin, y - h * sin - h * cos],\n        [x - h * cos - h * sin, y - h * sin + h * cos],\n      ]\n      return `M ${pts[0][0]} ${pts[0][1]} L ${pts[1][0]} ${pts[1][1]} L ${pts[2][0]} ${pts[2][1]} L ${pts[3][0]} ${pts[3][1]} Z`\n    }\n    case \"diamond\":\n    case \"filled-diamond\": {\n      const d = size * 0.8\n      return `M ${x + d * cos} ${y + d * sin} L ${x + d * sin} ${y - d * cos} L ${x - d * cos} ${y - d * sin} L ${x - d * sin} ${y + d * cos} Z`\n    }\n    case \"star\": {\n      let p = \"\"\n      const outer = size\n      const inner = size * 0.4\n      for (let i = 0; i < 10; i++) {\n        const ang = totalAngle + (i * Math.PI) / 5\n        const r = i % 2 === 0 ? outer : inner\n        const px = x + r * Math.cos(ang)\n        const py = y + r * Math.sin(ang)\n        p += i === 0 ? `M ${px} ${py}` : ` L ${px} ${py}`\n      }\n      return p + \" Z\"\n    }\n    case \"heart\": {\n      const s = size * 0.6\n      const hx1 = x - s * 0.5 * cos + s * 0.8 * sin\n      const hy1 = y - s * 0.5 * sin - s * 0.8 * cos\n      const hx2 = x + s * 0.5 * cos + s * 0.8 * sin\n      const hy2 = y + s * 0.5 * sin - s * 0.8 * cos\n      return `M ${x} ${y} C ${hx1} ${hy1} ${x - s * cos} ${y - s * sin} ${x - s * 0.5 * cos} ${y - s * 0.5 * sin} C ${x} ${y - s * sin} ${x + s * 0.5 * cos} ${y + s * 0.5 * sin} ${x + s * cos} ${y + s * sin} C ${hx2} ${hy2} ${x} ${y} ${x} ${y}`\n    }\n    case \"cross\": {\n      const s = size * 0.8\n      return `M ${x - s * cos} ${y - s * sin} L ${x + s * cos} ${y + s * sin} M ${x - s * sin} ${y + s * cos} L ${x + s * sin} ${y - s * cos}`\n    }\n    case \"plus\": {\n      const s = size * 0.8\n      return `M ${x - s * cos} ${y - s * sin} L ${x + s * cos} ${y + s * sin} M ${x} ${y - s} L ${x} ${y + s}`\n    }\n    case \"chevron\": {\n      const c = size * 0.8\n      const x1 = x - c * Math.cos(totalAngle - Math.PI / 4)\n      const y1 = y - c * Math.sin(totalAngle - Math.PI / 4)\n      const x2 = x - c * Math.cos(totalAngle + Math.PI / 4)\n      const y2 = y - c * Math.sin(totalAngle + Math.PI / 4)\n      return `M ${x1} ${y1} L ${x} ${y} L ${x2} ${y2}`\n    }\n    case \"double-chevron\": {\n      const c = size * 0.6\n      const x1 = x - c * Math.cos(totalAngle - Math.PI / 4)\n      const y1 = y - c * Math.sin(totalAngle - Math.PI / 4)\n      const x2 = x - c * Math.cos(totalAngle + Math.PI / 4)\n      const y2 = y - c * Math.sin(totalAngle + Math.PI / 4)\n      const x3 = x - c * 1.6 * Math.cos(totalAngle - Math.PI / 4)\n      const y3 = y - c * 1.6 * Math.sin(totalAngle - Math.PI / 4)\n      const x4 = x - c * 1.6 * Math.cos(totalAngle + Math.PI / 4)\n      const y4 = y - c * 1.6 * Math.sin(totalAngle + Math.PI / 4)\n      const cx = x - c * 0.8 * Math.cos(totalAngle)\n      const cy = y - c * 0.8 * Math.sin(totalAngle)\n      return `M ${x1} ${y1} L ${x} ${y} L ${x2} ${y2} M ${x3} ${y3} L ${cx} ${cy} L ${x4} ${y4}`\n    }\n    case \"line\": {\n      const s = size * 0.8\n      const lx1 = x - s * sin\n      const ly1 = y + s * cos\n      const lx2 = x + s * sin\n      const ly2 = y - s * cos\n      return `M ${lx1} ${ly1} L ${lx2} ${ly2}`\n    }\n    case \"dot\": {\n      const r = size * 0.3\n      return `M ${x + r} ${y} A ${r} ${r} 0 1 1 ${x - r} ${y} A ${r} ${r} 0 1 1 ${x + r} ${y}`\n    }\n    case \"dash\": {\n      const s = size * 0.6\n      const dx1 = x - s * Math.cos(totalAngle)\n      const dy1 = y - s * Math.sin(totalAngle)\n      const dx2 = x + s * Math.cos(totalAngle)\n      const dy2 = y + s * Math.sin(totalAngle)\n      return `M ${dx1} ${dy1} L ${dx2} ${dy2}`\n    }\n    default: {\n      // Fallback: simple open triangle.\n      const a = Math.PI / 6\n      const x1 = x - size * Math.cos(totalAngle - a)\n      const y1 = y - size * Math.sin(totalAngle - a)\n      const x2 = x - size * Math.cos(totalAngle + a)\n      const y2 = y - size * Math.sin(totalAngle + a)\n      return `M ${x} ${y} L ${x1} ${y1} M ${x} ${y} L ${x2} ${y2}`\n    }\n  }\n}\n\n/**\n * CurvedArrow\n *\n * Renders two sibling containers (UNDER and OVER) to solve stacking-context issues\n * with z-index. The UNDER container hosts the main path and any heads set to \"under\".\n * The OVER container hosts any heads set to \"over\" and optional local overlays.\n */\nconst CurvedArrow = React.forwardRef<HTMLDivElement, CurvedArrowProps>(\n  (\n    {\n      startElement,\n      endElement,\n      obstacleElements = [],\n      startX = 0,\n      startY = 0,\n      endX = 100,\n      endY = 100,\n      startPosition = \"center\",\n      endPosition = \"center\",\n\n      curveIntensity = 0.4,\n      curveType = \"smooth\",\n      curveDirection = \"auto\",\n\n      strokeWidth = 4,\n      arrowSize = 20,\n      color = \"#852DEE\",\n      gradientFrom = \"#ffffff\",\n      gradientTo = \"#852DEE\",\n\n      showStartArrow = false,\n      showEndArrow = true,\n      startArrowShape = \"triangle\",\n      endArrowShape = \"triangle\",\n      startArrowRotation = 0,\n      endArrowRotation = 0,\n      startArrowSize,\n      endArrowSize,\n\n      startArrowFilled = false,\n      endArrowFilled = false,\n\n      startArrowStrokeColor,\n      startArrowFillColor,\n      startArrowStrokeWidth,\n      startArrowOpacity,\n      endArrowStrokeColor,\n      endArrowFillColor,\n      endArrowStrokeWidth,\n      endArrowOpacity,\n\n      startHeadLayer = \"over\",\n      endHeadLayer = \"over\",\n\n      startLineOverHead = false,\n      endLineOverHead = false,\n\n      animated = true,\n      animationDuration = \"2s\",\n      animationDelay = \"0s\",\n      animationDirection = \"forward\",\n\n      ariaLabel = \"Curved arrow connector\",\n      variant,\n      size,\n      className,\n    },\n    _ref,\n  ) => {\n    /**\n     * Coordinates and obstacle rects, expressed relative to the container.\n     * This state is updated when refs move/resize or when direct coordinates change.\n     */\n    const [coordinates, setCoordinates] = useState<{\n      startX: number\n      startY: number\n      endX: number\n      endY: number\n      obstacleRects: RectLite[]\n    }>({\n      startX,\n      startY,\n      endX,\n      endY,\n      obstacleRects: [],\n    })\n\n    /**\n     * Container for the UNDER layer. All geometry calculations are relative to this element.\n     * Since it uses \"absolute inset-0\", its rect matches the positioned parent area.\n     */\n    const containerRef = useRef<HTMLDivElement>(null)\n\n    /**\n     * Unique base IDs for gradient/filter per layer to avoid ID collisions across multiple arrows.\n     */\n    const gradientIdBase = React.useId()\n    const filterIdBase = React.useId()\n\n    /**\n     * Re-entrancy guard for batched coordinate updates.\n     */\n    const isUpdatingRef = useRef(false)\n\n    /**\n     * Memoized obstacle count (array length is used in effects and loops).\n     */\n    const obstacleCount = obstacleElements?.length ?? 0\n\n    /**\n     * Convert an element's absolute rect into a relative anchor position inside the container.\n     * Applies a small padding so the arrow tip sits just outside the element edge.\n     */\n    const calculatePosition = useCallback((element: HTMLElement, position: string) => {\n      const rect = element.getBoundingClientRect()\n      const containerRect = containerRef.current?.getBoundingClientRect()\n      if (!containerRect) return { x: 0, y: 0 }\n\n      const relativeX = rect.left - containerRect.left\n      const relativeY = rect.top - containerRect.top\n      const padding = 5\n\n      switch (position) {\n        case \"top\":\n        case \"top-center\":\n          return { x: relativeX + rect.width / 2, y: relativeY - padding }\n        case \"bottom\":\n        case \"bottom-center\":\n          return { x: relativeX + rect.width / 2, y: relativeY + rect.height + padding }\n        case \"left\":\n        case \"left-center\":\n          return { x: relativeX - padding, y: relativeY + rect.height / 2 }\n        case \"right\":\n        case \"right-center\":\n          return { x: relativeX + rect.width + padding, y: relativeY + rect.height / 2 }\n        case \"center\":\n          return { x: relativeX + rect.width / 2, y: relativeY + rect.height / 2 }\n        case \"top-left\":\n          return { x: relativeX, y: relativeY }\n        case \"top-right\":\n          return { x: relativeX + rect.width, y: relativeY }\n        case \"bottom-left\":\n          return { x: relativeX, y: relativeY + rect.height }\n        case \"bottom-right\":\n          return { x: relativeX + rect.width, y: relativeY + rect.height }\n        case \"middle-left\":\n        case \"center-left\":\n          return { x: relativeX, y: relativeY + rect.height / 2 }\n        case \"middle-right\":\n        case \"center-right\":\n          return { x: relativeX + rect.width, y: relativeY + rect.height / 2 }\n        case \"middle-top\":\n        case \"center-top\":\n          return { x: relativeX + rect.width / 2, y: relativeY }\n        case \"middle-bottom\":\n        case \"center-bottom\":\n          return { x: relativeX + rect.width / 2, y: relativeY + rect.height }\n        default:\n          return { x: relativeX + rect.width / 2, y: relativeY + rect.height / 2 }\n      }\n    }, [])\n\n    /**\n     * Compute and set coordinate state from refs (if provided) or from direct props.\n     * Uses basic tolerance to prevent unnecessary state updates.\n     */\n    const updateCoordinates = useCallback(() => {\n      if (isUpdatingRef.current) return\n      isUpdatingRef.current = true\n      try {\n        if (startElement?.current && endElement?.current && containerRef.current) {\n          const sp = calculatePosition(startElement.current, startPosition)\n          const ep = calculatePosition(endElement.current, endPosition)\n\n          const obstacleRects: RectLite[] = []\n          if (obstacleCount > 0) {\n            for (let i = 0; i < obstacleCount; i++) {\n              const ref = obstacleElements[i]\n              if (ref?.current) {\n                const o = ref.current.getBoundingClientRect()\n                const c = containerRef.current.getBoundingClientRect()\n                obstacleRects.push({\n                  x: o.left - c.left,\n                  y: o.top - c.top,\n                  width: o.width,\n                  height: o.height,\n                })\n              }\n            }\n          }\n\n          setCoordinates((prev) => {\n            const same =\n              Math.abs(prev.startX - sp.x) < 0.5 &&\n              Math.abs(prev.startY - sp.y) < 0.5 &&\n              Math.abs(prev.endX - ep.x) < 0.5 &&\n              Math.abs(prev.endY - ep.y) < 0.5 &&\n              prev.obstacleRects.length === obstacleRects.length\n            if (same) return prev\n            return { startX: sp.x, startY: sp.y, endX: ep.x, endY: ep.y, obstacleRects }\n          })\n        } else {\n          // Fallback to direct coordinates when refs are not provided.\n          setCoordinates((prev) => {\n            const same =\n              Math.abs(prev.startX - startX) < 0.5 &&\n              Math.abs(prev.startY - startY) < 0.5 &&\n              Math.abs(prev.endX - endX) < 0.5 &&\n              Math.abs(prev.endY - endY) < 0.5 &&\n              prev.obstacleRects.length === 0\n            if (same) return prev\n            return { startX, startY, endX, endY, obstacleRects: [] }\n          })\n        }\n      } finally {\n        isUpdatingRef.current = false\n      }\n    }, [\n      startElement,\n      endElement,\n      startPosition,\n      endPosition,\n      startX,\n      startY,\n      endX,\n      endY,\n      calculatePosition,\n      obstacleElements,\n      obstacleCount,\n    ])\n\n    /**\n     * Recompute when docking positions or direct coordinates change.\n     */\n    useEffect(() => {\n      updateCoordinates()\n    }, [startPosition, endPosition, startX, startY, endX, endY, obstacleCount, updateCoordinates])\n\n    /**\n     * Observe start/end/obstacle elements for size/DOM changes and update coordinates.\n     * Also reacts to window resize and scroll (in case layout shifts).\n     */\n    useEffect(() => {\n      if (!startElement?.current || !endElement?.current) return\n      const resizeObserver = new ResizeObserver(() => requestAnimationFrame(updateCoordinates))\n      const mutationObserver = new MutationObserver(() => requestAnimationFrame(updateCoordinates))\n\n      const els: HTMLElement[] = [startElement.current, endElement.current]\n      for (let i = 0; i < obstacleCount; i++) {\n        const cur = obstacleElements[i]?.current\n        if (cur) els.push(cur)\n      }\n\n      els.forEach((el) => {\n        resizeObserver.observe(el)\n        mutationObserver.observe(el, { attributes: true, childList: true, subtree: true })\n      })\n\n      const onResize = () => requestAnimationFrame(updateCoordinates)\n      const onScroll = () => requestAnimationFrame(updateCoordinates)\n      window.addEventListener(\"resize\", onResize, { passive: true })\n      window.addEventListener(\"scroll\", onScroll, { passive: true })\n\n      return () => {\n        resizeObserver.disconnect()\n        mutationObserver.disconnect()\n        window.removeEventListener(\"resize\", onResize)\n        window.removeEventListener(\"scroll\", onScroll)\n      }\n    }, [startElement?.current, endElement?.current, obstacleCount, updateCoordinates, obstacleElements])\n\n    /**\n     * Compute the main curve's path string and the second control anchor\n     * used to derive tangents for the head orientations.\n     */\n    const createCurvePath = React.useMemo(() => {\n      const { startX: sx, startY: sy, endX: ex, endY: ey, obstacleRects } = coordinates\n      const dx = ex - sx\n      const dy = ey - sy\n      const distance = Math.hypot(dx, dy)\n\n      // Directional bias. \"auto\" chooses a dominant axis based on deltas.\n      let effectiveDirection = curveDirection\n      if (curveDirection === \"auto\") {\n        if (Math.abs(dx) > Math.abs(dy)) {\n          effectiveDirection = dy > 0 ? \"up\" : \"down\"\n        } else {\n          effectiveDirection = dx > 0 ? \"left\" : \"right\"\n        }\n      }\n\n      let offsetX = 0\n      let offsetY = 0\n      const baseOffset = Math.min(distance * curveIntensity, 150)\n\n      switch (effectiveDirection) {\n        case \"up\":\n          offsetY = -baseOffset\n          break\n        case \"down\":\n          offsetY = baseOffset\n          break\n        case \"left\":\n          offsetX = -baseOffset\n          break\n        case \"right\":\n          offsetX = baseOffset\n          break\n      }\n\n      let pathString = \"\"\n      // The second control point (for cubic) or the last waypoint used to infer end tangent.\n      let control2X = ex\n      let control2Y = ey\n\n      switch (curveType) {\n        case \"smooth\": {\n          const c1x = sx + dx * 0.3 + offsetX * 0.5\n          const c1y = sy + dy * 0.3 + offsetY * 0.5\n          control2X = ex - dx * 0.3 + offsetX * 0.5\n          control2Y = ey - dy * 0.3 + offsetY * 0.5\n          pathString = `M ${sx} ${sy} C ${c1x} ${c1y} ${control2X} ${control2Y} ${ex} ${ey}`\n          break\n        }\n        case \"dramatic\": {\n          const c1x = sx + dx * 0.1 + offsetX * 1.5\n          const c1y = sy + dy * 0.1 + offsetY * 1.5\n          control2X = ex - dx * 0.1 + offsetX * 1.5\n          control2Y = ey - dy * 0.1 + offsetY * 1.5\n          pathString = `M ${sx} ${sy} C ${c1x} ${c1y} ${control2X} ${control2Y} ${ex} ${ey}`\n          break\n        }\n        case \"s-curve\": {\n          const c1x = sx + dx * 0.25 + offsetX * 0.8\n          const c1y = sy + dy * 0.25 + offsetY * 0.8\n          control2X = ex - dx * 0.25 - offsetX * 0.8\n          control2Y = ey - dy * 0.25 - offsetY * 0.8\n          pathString = `M ${sx} ${sy} C ${c1x} ${c1y} ${control2X} ${control2Y} ${ex} ${ey}`\n          break\n        }\n        case \"wave\": {\n          pathString = `M ${sx} ${sy}`\n          const segments = 8\n          for (let i = 1; i <= segments; i++) {\n            const t = i / segments\n            const x = sx + dx * t\n            const y = sy + dy * t + Math.sin(t * Math.PI * 4) * baseOffset * 0.3\n            const pt = (i - 1) / segments\n            const px = sx + dx * pt\n            const py = sy + dy * pt + Math.sin(pt * Math.PI * 4) * baseOffset * 0.3\n            const cpx = (px + x) / 2\n            const cpy = (py + y) / 2\n            pathString += ` Q ${cpx} ${cpy} ${x} ${y}`\n          }\n          // Approximate end control for tangent calculation.\n          control2X = sx + dx * 0.875\n          control2Y = sy + dy * 0.875\n          break\n        }\n        case \"elegant\": {\n          const midX = (sx + ex) / 2 + offsetX * 0.8\n          const midY = (sy + ey) / 2 + offsetY * 0.8\n          const c1x = sx + dx * 0.2 + offsetX * 0.4\n          const c1y = sy + dy * 0.2 + offsetY * 0.4\n          control2X = ex - dx * 0.2 + offsetX * 0.4\n          control2Y = ey - dy * 0.2 + offsetY * 0.4\n          pathString = `M ${sx} ${sy} C ${c1x} ${c1y} ${midX} ${midY} ${midX} ${midY} S ${control2X} ${control2Y} ${ex} ${ey}`\n          break\n        }\n        case \"zigzag\": {\n          pathString = `M ${sx} ${sy}`\n          const segments = 6\n          for (let i = 1; i <= segments; i++) {\n            const t = i / segments\n            const x = sx + dx * t\n            const zz = i % 2 === 0 ? baseOffset * 0.4 : -baseOffset * 0.4\n            const y = sy + dy * t + zz\n            pathString += ` L ${x} ${y}`\n          }\n          pathString += ` L ${ex} ${ey}`\n          // Approximate control to derive tangent for head orientation.\n          control2X = sx + dx * 0.833\n          control2Y = sy + dy * 0.833\n          break\n        }\n        case \"around-obstacle\":\n        case \"shortest-path\": {\n          const obs = obstacleRects\n          if (obs.length) {\n            pathString = `M ${sx} ${sy}`\n            let cx = sx\n            let cy = sy\n            obs.forEach((o) => {\n              // Simple detour heuristic: create a waypoint that clears the obstacle box with margin.\n              const margin = 25\n              const left = o.x - margin\n              const right = o.x + o.width + margin\n              const top = o.y - margin\n              const bottom = o.y + o.height + margin\n              const intersects = cx < right && ex > left && Math.min(cy, ey) < bottom && Math.max(cy, ey) > top\n              if (intersects) {\n                const goRight = ex > o.x + o.width / 2\n                const goUp = ey < o.y + o.height / 2\n                const wayX = goRight ? right + 20 : left - 20\n                const wayY = goUp ? top - 10 : bottom + 10\n                pathString += ` L ${wayX} ${wayY}`\n                cx = wayX\n                cy = wayY\n              }\n            })\n            pathString += ` L ${ex} ${ey}`\n            // Use last waypoint as a pseudo-control to align head orientation.\n            control2X = cx\n            control2Y = cy\n          } else {\n            // Fallback to a smooth cubic if no obstacles.\n            const c1x = sx + dx * 0.3\n            const c1y = sy + dy * 0.3\n            control2X = ex - dx * 0.3\n            control2Y = ey - dy * 0.3\n            pathString = `M ${sx} ${sy} C ${c1x} ${c1y} ${control2X} ${control2Y} ${ex} ${ey}`\n          }\n          break\n        }\n        default: {\n          // Default: similar to \"smooth\" with mild bias in the chosen direction.\n          const c1x = sx + dx * 0.3 + offsetX * 0.5\n          const c1y = sy + dy * 0.3 + offsetY * 0.5\n          control2X = ex - dx * 0.3 + offsetX * 0.5\n          control2Y = ey - dy * 0.3 + offsetY * 0.5\n          pathString = `M ${sx} ${sy} C ${c1x} ${c1y} ${control2X} ${control2Y} ${ex} ${ey}`\n        }\n      }\n      return { pathString, control2X, control2Y }\n    }, [coordinates, curveType, curveDirection, curveIntensity])\n\n    // Destructure computed path and anchors for orientation/tangents.\n    const { pathString, control2X, control2Y } = createCurvePath\n    const { startX: sx, startY: sy, endX: ex, endY: ey } = coordinates\n\n    // Effective head sizes (use per-head override if provided).\n    const effStartSize = startArrowSize || arrowSize\n    const effEndSize = endArrowSize || arrowSize\n\n    // Tangents for head orientations.\n    const startTangent = Math.atan2(control2Y - sy, control2X - sx)\n    const endTangent = Math.atan2(ey - control2Y, ex - control2X)\n\n    // Final head angles at each end.\n    const startAngle = startTangent + Math.PI\n    const endAngle = endTangent\n\n    // Construct head path strings (or empty if disabled).\n    const startHeadPath =\n      showStartArrow &&\n      createArrowHead(sx, sy, startAngle, effStartSize, startArrowShape, startArrowRotation, startArrowFilled)\n    const endHeadPath =\n      showEndArrow && createArrowHead(ex, ey, endAngle, effEndSize, endArrowShape, endArrowRotation, endArrowFilled)\n\n    // When both gradientFrom and gradientTo are present, use gradient stroke; otherwise solid color.\n    const hasGradient = !!(gradientFrom && gradientTo)\n\n    // Local overlay segments to visually place the line over heads when they share a layer.\n    const overlayLen = Math.max(strokeWidth * 2 + 6, 12)\n    const startOverlayPath = `M ${sx - Math.cos(startTangent) * overlayLen} ${sy - Math.sin(startTangent) * overlayLen} L ${sx} ${sy}`\n    const endOverlayPath = `M ${ex - Math.cos(endTangent) * overlayLen} ${ey - Math.sin(endTangent) * overlayLen} L ${ex} ${ey}`\n\n    // Shared class for both UNDER and OVER containers.\n    const arrowClass = cn(curvedArrowVariants({ variant, size }), className)\n\n    /**\n     * Render the SVG for one layer.\n     *\n     * UNDER layer:\n     *  - Renders main line (optionally with glow) and optional animated dash overlay.\n     *  - Renders any heads configured to headLayer=\"under\".\n     *  - Can draw a tiny overlay segment if startLineOverHead/endLineOverHead is true.\n     *\n     * OVER layer:\n     *  - Renders heads configured to headLayer=\"over\" and optional local overlay segment.\n     *  - Does NOT render the main line (to avoid stacking twice).\n     */\n    const renderSVG = (layer: \"under\" | \"over\") => {\n      // Unique IDs per layer avoid collisions across multiple CurvedArrow instances.\n      const gid = `${gradientIdBase}-${layer}`\n      const fid = `${filterIdBase}-${layer}`\n\n      const showStartOnLayer = !!startHeadPath && startHeadLayer === layer\n      const showEndOnLayer = !!endHeadPath && endHeadLayer === layer\n      const showLineOnLayer = layer === \"under\" // main path is only drawn on UNDER\n\n      // Determine effective stroke/fill sources.\n      const defaultStroke = hasGradient ? `url(#${gid})` : color\n      const sStroke = startArrowStrokeColor ?? defaultStroke\n      const eStroke = endArrowStrokeColor ?? defaultStroke\n      const sFill = startArrowFillColor ?? defaultStroke\n      const eFill = endArrowFillColor ?? defaultStroke\n\n      return (\n        <svg width=\"100%\" height=\"100%\" className=\"absolute inset-0\" preserveAspectRatio=\"none\" aria-hidden=\"true\">\n          <defs>\n            <linearGradient id={gid} x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">\n              <stop offset=\"0%\" stopColor={gradientFrom} />\n              <stop offset=\"100%\" stopColor={gradientTo} />\n            </linearGradient>\n            <filter id={fid}>\n              <feGaussianBlur stdDeviation=\"3\" result=\"coloredBlur\" />\n              <feMerge>\n                <feMergeNode in=\"coloredBlur\" />\n                <feMergeNode in=\"SourceGraphic\" />\n              </feMerge>\n            </filter>\n          </defs>\n\n          {/* Optional glow for certain variants */}\n          {showLineOnLayer &&\n            (variant === \"glow\" ||\n              variant === \"neon\" ||\n              variant === \"fire\" ||\n              variant === \"electric\" ||\n              variant === \"cosmic\") && (\n              <path\n                d={pathString}\n                stroke={defaultStroke}\n                strokeWidth={strokeWidth + 4}\n                fill=\"none\"\n                strokeLinecap=\"round\"\n                opacity=\"0.4\"\n                filter={`url(#${fid})`}\n              />\n            )}\n\n          {/* Main line */}\n          {showLineOnLayer && (\n            <path d={pathString} stroke={defaultStroke} strokeWidth={strokeWidth} fill=\"none\" strokeLinecap=\"round\" />\n          )}\n\n          {/* Animated white dash overlay on the main path */}\n          {showLineOnLayer && animated && (\n            <path\n              d={pathString}\n              stroke=\"#ffffff\"\n              strokeWidth=\"2\"\n              fill=\"none\"\n              strokeDasharray=\"12,8\"\n              strokeLinecap=\"round\"\n              opacity=\"0.8\"\n              style={{ animationDelay, animationDirection }}\n            >\n              <animate\n                attributeName=\"stroke-dashoffset\"\n                values={\n                  animationDirection === \"reverse\" || animationDirection === \"alternate-reverse\" ? \"20;0\" : \"0;20\"\n                }\n                dur={animationDuration}\n                repeatCount=\"indefinite\"\n              />\n            </path>\n          )}\n\n          {/* Heads on this layer */}\n          {showStartOnLayer && (\n            <path\n              d={startHeadPath!}\n              stroke={sStroke}\n              strokeWidth={startArrowStrokeWidth ?? strokeWidth}\n              fill={startArrowFilled || (startArrowShape || \"\").includes(\"filled\") ? sFill : \"none\"}\n              strokeLinecap=\"round\"\n              opacity={startArrowOpacity ?? 1}\n            />\n          )}\n          {showEndOnLayer && (\n            <path\n              d={endHeadPath!}\n              stroke={eStroke}\n              strokeWidth={endArrowStrokeWidth ?? strokeWidth}\n              fill={endArrowFilled || (endArrowShape || \"\").includes(\"filled\") ? eFill : \"none\"}\n              strokeLinecap=\"round\"\n              opacity={endArrowOpacity ?? 1}\n            />\n          )}\n\n          {/* Optional small overlays to place the line visually over the head */}\n          {showStartOnLayer && startLineOverHead && (\n            <path\n              d={startOverlayPath}\n              stroke={defaultStroke}\n              strokeWidth={strokeWidth}\n              fill=\"none\"\n              strokeLinecap=\"round\"\n            />\n          )}\n          {showEndOnLayer && endLineOverHead && (\n            <path\n              d={endOverlayPath}\n              stroke={defaultStroke}\n              strokeWidth={strokeWidth}\n              fill=\"none\"\n              strokeLinecap=\"round\"\n            />\n          )}\n        </svg>\n      )\n    }\n\n    /**\n     * Render two sibling containers with explicit z-index to guarantee correct stacking\n     * relative to your elements. Ensure the parent container is positioned (relative).\n     */\n    return (\n      <>\n        {/* UNDER container: z-2 (above your \"under\" elements in z-1) */}\n        <div ref={containerRef} className={arrowClass} aria-label={ariaLabel} role=\"img\" style={{ zIndex: 2 }}>\n          {renderSVG(\"under\")}\n        </div>\n\n        {/* OVER container: z-4 (below your \"over\" elements in z-5) */}\n        <div className={arrowClass} aria-hidden=\"true\" style={{ zIndex: 4 }}>\n          {renderSVG(\"over\")}\n        </div>\n      </>\n    )\n  },\n)\n\nCurvedArrow.displayName = \"CurvedArrow\"\n\nexport { CurvedArrow, curvedArrowVariants }\n",
      "type": "registry:component",
      "target": "components/ui/curved-arrow.tsx"
    }
  ]
}